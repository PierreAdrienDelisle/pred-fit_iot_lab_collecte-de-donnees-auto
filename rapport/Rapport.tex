\documentclass[11pt, french, screen, research-development]{report-rd-info}
   % - 11pt:  12pt peut être préférable pour faciliter la lecture sur les petits écrans, demander à l'encadrement
   % - french:  à remplacer par english en cas de rédaction (exceptionnelle) en anglais
   % - screen:  à enlever pour obtenir un rapport au format A4
   % - research-development:  à remplacer par 'research' seul, ou 'development' seul, voire 'intelligence' en fonction de la demande du jury à l'issue du travail
\usepackage[latin1]{inputenc}
   % - latin9, utf8, etc.
\usepackage[T1]{fontenc}
\usepackage{babel}

% définitions propres au contenu actuel
\usepackage{enumerate}
\usepackage{amsmath, amssymb}
\usepackage{algorithm}
   \floatname{algorithm}{Algorithme}
   \ifenglish
      \renewcommand{\listalgorithmname}{List of Algorithms}
   \else
      \renewcommand{\listalgorithmname}{Liste des algorithmes}
   \fi
\usepackage{listings}
   \lstset{backgroundcolor={\color{yellow}},
           columns=fullflexible,
           commentstyle={\color{blue}},
           numbers=left,
           numbersep=5pt,
           numberstyle={\tiny},
           stepnumber=1}
\usepackage{algorithmic}
\usepackage{xcolor}
\usepackage{float}
\usepackage{url}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{graphicx}

\newenvironment{typographie}{\begin{quote}\textbf{Typographie}. }{\end{quote}}
\newenvironment{structuration}{\begin{quote}\textbf{Structuration}. }{\end{quote}}

\newtheorem{theoreme}{Théorème}
\newtheorem{preuve}{Preuve}

\begin{document}

\title{Rapport final}
\subtitle{Collecte automatique de données}
\authorA{Pierre-Adrien}{Delisle}
\authorB{Samuele}{Da Silva}
\supervisor{Benoit}{Parrein}
\cosupervisor{Julien}{Vandaele}
   % Si plusieurs co-encadrants, alors utiliser la forme suivante~:
   %    \cosupervisor{Alter}{Ego \& {\normalfont Jean} Cadre}
\coordinator{Philippe}{Leray}
\institution{LS2N}
   % - LS2N (fusion de l'ex LINA et de l'ex IRCCyN) pour un encadrement par les membres des équipes du département (voire d'autres équipes du LS2N) ;
   % - XXX pour un encadrement dans le cadre d'un autre organisme
   %   (il faut alors fournir dans le répertoire "logos" les fichiers correspondant~: XXX.pdf -- à défaut XXX.jpeg ou XXX.png -- pour pdflatex *et* XXX.eps pour latex) ;
   % - commenter pour un encadrement qui relève d'un travail de recherche non affecté à une équipe.
\theme{\'Equipe RIO}
   % - à fournir dans le cas d'un laboratoire (DUKE, IPI ou RIO pour les équipes du département)
   % - commenter autrement
   % - ne peut pas être fourni si l'institution n'a pas été renseignée
\coinstitution{Inria}{inria}{3cm}
   % - pour ajouter un partenaire
   % - le logo doit correspondre au fichier déclaré, ici CNRS.pdf.
   % - le troisième paramètre permet d'adapter la largeur du logo afin
   %   de le rendre visuellement comparable à ceux mis par défaut (université de Nantes et
   %   éventuellement laboratoire)
\date{04 février 2020}
   % - en français les mois ne prennent pas de majuscule (sauf si vous ne mettez pas le jour)
   % - inutile de mettre un 0 devant les jours 1 à 9 du mois~!
   % - le jour est peut-être même une précision inutile...

%-------------------------------------------------------------------------------------------------------------

\begin{abstract}
%\small % À décommenter si le résumé est légèrement trop long pour tenir dans la page

La plateforme FIT (Future Internet Testing facility) IoT lab, créée pour tester différentes aspects importants pour les thématiques qui entourent l'Internet des objets, est constituée de 6 sites, répartis en France, qui contiennent de nombreux n\oe uds capteurs, et permettent de nombreuses expérimentations.

La problème, très technique, est ici de collecter automatiquement, à intervalles réguliers dans la journée, différentes données sur des puces M3, qui constituent la majorité du parc de la plateforme FIT Lilloise, telles que la luminosité ou la température. Les objectifs pour arriver à une solution sont donc les suivantes:
\begin{enumerate}
   \item Développement et Implémentation d'un firmware pour les n\oe uds m3, permettant de récupérer les données et de les pousser sur lien série ~;
   \item Développement d'un script python qui crée les expériences nécessaires, récupère les données poussées par les n\oe uds, et les pousse dans une base temporelle~;
   \item Récupération, stockage et visualisation des données~;
\end{enumerate}
\end{abstract}
\begin{classification}
%\small % Idem
   \terms{Internet des objets, FIT IoT, Données, Acquisition, Représentation, Stockage, Radio.}
   \keywords{Captation automatique, N\oe uds m3, Lille, protocole, RPL, perturbations}
\end{classification}

\maketitle

%-------------------------------------------------------------------------------------------------------------

\begin{acknowledgements}
	Nous remercions Bastien Confais pour sa rigueur et son investissement dans notre travail, Benoit Parrein pour le suivi et les retours très rapides sur le travail effectué, Julien Vandaele pour sa disponibilité, ses explications très claires et ses retours très rapides à nos questions
\end{acknowledgements}

%-------------------------------------------------------------------------------------------------------------

\newpage

\tableofcontents

%-------------------------------------------------------------------------------------------------------------

\chapter{Introduction}

\section{Sujet d'étude}

Ce projet s'inscrit dans l'environnement FIT IoT Lab, une plateforme d'expérimentation pour l'internet des objets. Composée de 6 sites répartis dans toute la France, chacun d'entre eux contient un grand nombre de plusieurs types de n\oe uds, qui permettent différentes expériences à distance. Ces n\oe uds sont généralement des cartes électroniques, mobiles ou non, qui contiennent différents équipements: 
\begin{itemize}
\item Capteurs
\item Equipement radio pour communication avec des voisins
\item LEDs
\item Robot sur lequel est posée la carte
\end{itemize}

Il existe différents types de n\oe uds qui ont différents fonctionnements et buts, comme les capteurs m3 qui sont les cartes que l'on utilise. Nous présenterons ces cartes plus en détail dans la suite du document.

Ces n\oe uds sont répartis à l'échelle d'un bâtiment dans chaque site de la plateforme, ce qui permet une cartographie par les cartes de ces sites. 

\section{Présentation de la problématique}

En se basant sur cette plateforme, les chercheurs de l'Inria, à Lille voudraient avoir à disposition des données temporelles sur leur bâtiment d'étude, qui pourrait dès lors s'apparenter à un bâtiment intelligent. Dès qu'elles seront disponibles, ces données constitueront une base libre qui, nous l'espérons, pourra être exploitée par les chercheurs pour différentes expérimentations. Ceci a donc pour but de faire gagner du temps à la recherche, ainsi qu'à fournir une méthode pour capter de nouvelles données.
Ces données seront captées par des n\oe uds m3. Ces n\oe uds particuliers constituent une grande majorité du parc Lillois, et nous permettent donc d'obtenir une masse de données importante sur ce site.

Par ailleurs, et grâce à cette masse de données, nous souhaitons étudier une seconde question: Dans une plateforme telle que FIT IoT, on peut se demander quel est l'impact des expériences des autres utilisateurs sur nos propres expérimentations. Nous souhaitons de fait étudier l'impact que peut avoir l'exploitation de la plateforme sur un protocole radio, et ainsi étudier la reproductibilité de ces expériences. 

\section{Objectifs poursuivis}

Dans un premier temps, l'objectif principal est bien la mise en place de cette solution de captation automatique. En effet, ces capteurs étant répartis dans tout le bâtiment Lillois, il peut être intéressant de monitorer ces cartes afin d'obtenir des informations sur l'endroit, et ainsi potentiellement en faire un bâtiment intelligent.

Il faut donc que toutes les briques logicielles soient mises en place afin de pouvoir remplir une base de données à destination des chercheurs.

Par la suite, il nous faudra proposer une documentation extensive du travail fourni pour assurer une continuation du projet.

Puis une mise en place d'un protocole radio afin de mettre en évidence ou non, la possible perturbation radio induite entre expériences ou par l'environnement utilisé par de nombreuses personnes diverses (hall d'entrée d'un bâtiment).

\section{Travail à réaliser et travail réalisé}

Afin de satisfaire notre objectif principal; la collecte de données automatiques de capteurs m3 ; il nous faut mettre en place plusieurs briques, qu'elles soient logicielles ou d'infrastructure. Dans notre problème, comme chaque partie de la plateforme est exploitée, il nous faut développer une solution pour chaque partie:
\begin{enumerate}
   \item Au niveau des n\oe uds, il nous une solution logicielle de captation de données. Une fois captées, ces données doivent nous être renvoyées pour traitement et écriture dans la base de données.
   \item Pour stocker les données captées par cette solution, il nous faut préparer et implémenter une base de données de type temporelle, qui est une solution adaptée à notre problématique liée au format des données: De très nombreuses petites mesures estampillées.
   \item Enfin, il nous faut un applicatif qui se place entre ses deux solutions et qui permette de faire la jonction entre elles. Ici, ce serait un script qui contrôlerait tout, de la réservation des noeuds, à l'exploitation des données et leur envoi dans la base.
\end{enumerate}
   
Notre second objectif, qui est donc d'observer l'impact des perturbations radio sur les expériences de la plateforme FIT IoT lab, nécessitera aussi plusieurs briques qui permetteront de conclure
\begin{enumerate}
   \item Il nous faut un protocole radio à étudier, afin de déterminer les effets de ces perturbations;
   \item Il nous faut surveiller ce protocole, récupérer plusieurs métriques quant à son fonctionnement, afin de déterminer si oui ou non il y a de réelles perturbations.
   \item Enfin, il nous faut tester ce protocole dans des conditions volontairement perturbées afin de vérifier les limites de ce protocole.
   
\end{enumerate}
   


Le premier objectif est totalement satisfait, à savoir que, la solution de collecte automatique est mise en place via plusieurs technologies : 
\begin{enumerate}
   \item Contiki pour le firmware ~;
   \item InfluxDB pour la base de données ~;
   \item Script python associé à cron pour l'automatisation~;
\end{enumerate}


Le second objectif, en revanche, n'aura pas pu être mené a bien dans le temps imparti. En effet, nous avons défini cet objectif que relativement tard dans le projet, et n'y avons que peu réfléchi

De ce fait, bien que nous ayons mené une expérimentation, qui sera présentée dans la suite du rapport, la masse de données que nous avons récuperée est trop faible pour pouvoir établir une réelle conclusion. En effet, après une première partie ou nous pensions avoir trouvé une réelle reproductibilité d'expérience, nous avons observé qu'en augmentant le nombre de n\oe uds sur lesquels nous effectuons nos expériences, et même dans le cas où la plateforme ne subit que très peu de perturbations, la reproductibilité du protocole n'a pas pu être vérifiée.

Le but était de montrer que l'activité de la plateforme, que ce soit au travers des expériences ou de l'activité humaine sur le site de Lille, pouvait avoir un impact assez important sur les expériences menées par les utilisateurs, par exemple avec une expérience de routage. Nous voulions de ce fait utiliser les technologies suivantes:
\begin{enumerate}
   \item Contiki pour le firmware des n\oe uds qui sont routés;
   \item Profil de monitoring pour vérifier le niveau de RSSI pendant l'expérience
\end{enumerate}



\section{Plan de l'étude}

Ce rapport contient les différentes étapes du projet, à savoir la collecte de données automatique puis la captation radio et son impact réseau. Dans les parties à suivre, il y aura donc, premièrement, une présentation de la solution mêlée dans un second temps au recherches sur les perturbations radio.


Le chapitre~\ref{chap:EtatArt} se concentrera sur les études technologiques et la montée en compétence que nous avons effectuée sur ce début de projet.  L'état de l'art sera donc technique avec la présentation de la plateforme, les firmwares M3 et les bases de données temporelles. Puis ensuite, une partie dédié aux métriques réseaux et impacts sur la qualité des protocoles.

Le chapitre~\ref{chap:Conception} est dédié aux différents choix technologiques, diagrammes et concepts qui forment notre système. Ainsi que l'exploitation du protocole réseau RPL (Routing Protocol for Low-Power and Lossy Networks) qui sera utilisé pour tester nos hypothèses. Il est central car il constitue une base de travail solide sur laquelle se retourner à tout moment lors du travail pour notre groupe.

%-------------------------------------------------------------------------------------------------------------

% \part{\'Etat de l'art} % À décommenter si l'état de l'art nécessite plusieurs chapitres.
                         % Ce sera le cas si l'état de l'art est riche, où l'on distinguera un chapitre de présentation d'un chapitre critique.
                         % Il faudra aussi décommenter la partie sur le travail réalisé
% \label{part:EtatArt}

\chapter{\'Etat de l'art}
\label{chap:EtatArt}

\section{Plateforme Fit IoT Lab}

\subsection{Présentation}

	IoT Lab fait partie du consortium FIT (Future Internet Testing facility) qui réuni plusieurs institutions de recherche et universités sur ce projet de plateforme de tests à grande échelle : FIT IoT Lab, FIT Wireless et FIT Cloud.
	FIT IoT Lab est une plateforme de service  d'infrastructure IoT. Il existe sur cette plateforme plus de 1500 noeuds capteurs de différents types (M3,A8,turtlebot,...) répartis sur 6 sites : Grenoble, Lille, Lyon, Paris, Saclay et Strasbourg. L'objectif est de fournir aux chercheurs une infrastructure riche qu'ils peuvent ensuite réserver et tester pour leur propres expériences en utilisant ces noeuds.
	
	

\subsection{Architecture IoT Lab}
La plateforme est décomposée en plusieurs parties (figure \ref{fig:graphArchi}):
\begin{itemize}
	\item Site web - FIT IoT Lab (Webportal) 
	
	Il permet d'accéder au banc d'essai en ligne, réserver des noeuds capteurs pour une expérience avec un firmware dédié et une durée. Il contient aussi les tutoriels permettant de prendre en main la plateforme. Celui-ci est un client de l'API REST.
	
	\item L'API REST 
	
	Cette API REST contient une multitude d'appels pour différents besoins. On peut obtenir l'état du banc d'essai sur n'importe quel site ou alors se concentrer sur une expérience en cours ou passée pour obtenir des détails sur celle-ci.  Elle contient par ailleurs des possibilités de modifier un firmware en cours d'expériences ou d'obtenir plus d'informations sur des robots en mobilité.
	
	\item Frontend SSH
	
	La frontend SSH est un serveur distant auquel chaque utilisateur de FIT IoT Lab peut se connecter via son compte sur un site particulier, dans le cadre de notre étude Lille. Elle est utile pour lancer directement des expériences, les gérer et prendre des informations diverses et variées. Cette frontend SSH s'appuie sur l'API REST pour fonctionner mais elle permet d'utiliser des scripts en local sur cet ordinateur distant afin de réaliser des tâches plus complexes comme le "serial aggregator" qui va agréger toutes les entrées des liens séries de nos noeuds. Les scripts sont écrits généralement en Python. De plus, cet accès permet par la suite de se connecter directement aux noeuds d'une expérience qu'on aurait lancé pour observer son comportement en détails.
	
	\item Noeuds capteurs
	
	Il existe plusieurs types de noeuds : A8, M3, Firefly, Lora, Arduino, WSN430 et les turtlebots qui sont des unités mobiles. Chaque noeud à une documentation qui lui est propre. Cela permet une grande diversité dans l'expérimentation. Sur ces noeuds il faut ajouter un firmware pour obtenir le comportement par défaut attendu de chacun d'eux, le développement firmware s'effectue en C.
	
	\item Noeuds M3 (figure \ref{fig:carteM3})
	
	Il est essentiel de parler des capacités des noeuds M3 puisqu'ils seront notre objet d'étude sur les différentes problématiques traitées. 
	La carte contient plusieurs capteurs de mesures ambiantes : lumière, pression, gyroscope, accéléromètre.
	Pour les communications radio, la carte utilise la norme 802.15.4 PHY 2.4 Ghz. 
	La carte peut s'utiliser avec les différents OS (Operating System) suivants : Contiki, RIOT et FreeRTOS.
	
	
	\begin{figure}[h]
    \includegraphics[width=0.5\textwidth]{Images/m3}
    \caption{Carte M3}
    \label{fig:carteM3}
	\end{figure}	
	
	\end{itemize}

	Un noeud M3 est composé (figure \ref{fig:noeudM3}) :
\begin{itemize}
	\item De la carte M3 (Open Node) qui va être manipulé par l'utilisateur qui va avoir un accès total dessus (mémoire, OS et firmware utilisé).
	\item Une Gateway qui permet la connexion à cette carte et accès à son port série.
	\item Un noeud de contrôle (Control Node) qui va être le moyen d'envoyer ses instructions passives ou actives à la carte via la gateway et récupérer les données collectées de l'open-node.
\end{itemize}

	\begin{figure}[h]
    \includegraphics[width=0.5\textwidth]{Images/what-is-a-node}
    \caption{Noeud M3}
    \label{fig:noeudM3}
	\end{figure}	
	
Dans la suite, nous discuterons indistinctement de la carte m3 et du noeud m3.

	
\begin{figure}[hp]
    \includegraphics[width=0.5\textwidth]{Images/resume-fit}
    \caption{Graphique architecture FIT IoT Lab}
    \label{fig:graphArchi}
\end{figure}	
	
	
\subsection{Tutoriels essentiels}

Dans cette section, nous présenterons les tutoriels essentiels de la plateforme que nous avons dû suivre pour réaliser notre solution.
	\begin{itemize}
		\item Getting started: the tutorial for beginners  [1]
		
		Ce tutoriel vise à faire une première soumission d'expérience via la plateforme web : réserver des noeuds, ajouter un firmware et y accéder directement via SSH sur le banc d'essai. Cela nous a permis entre autre de découvrir la plateforme dans son ensemble et comprendre le but visé de celle-ci.
			
		\item SSH access [2]
		
		Cette partie permet d'obtenir un accès  SSH sur la frontend en faisant un échange de clé RSA via le site web. Nous avons donc pu grâce à ceci configurer un accès privilégié à notre compte sur la frontend SSH, d'ici nous avons pu déployer notre script et accéder aux noeuds d'une expérience en SSH.
		
		\item Experiment CLI Client [3]
		
		Ce tutoriel fait partie d'un ensemble de tutoriels à propos des "CLI tools" qui permettent de faire des appels à l'API REST en soumettant des expériences, en flashant les firmwares des noeuds etc... Celui-ci permet d'apprendre la partie "experiment" qui concerne la soumission d'expérience ainsi que de son suivi. Cela nous permet donc d'apprendre la plus grande partie des commandes relatives aux CLI Tools et savoir sur quoi s'appuyer pour notre script comme la soumission d'expérience ou encore récupérer l'état de la plateforme afin de savoir la disponibilité de celle-ci.
		
		\item Nodes Serial Link Aggregation [4]
		
		Une présentation du script "serial aggregator" qui permet d'agréger tous les liens séries relatifs à une expérience. Il permet aussi d'envoyer des messages à tous les liens qu'il agrège. Cette partie est essentielle pour notre projet puisque cet outil permettra d'agréger les données de tous nos noeuds M3 lors des expériences. 
		
		
		
\end{itemize}	 


\section{Firmwares}

Comme expliqué par avant, la plateforme contient un grand nombre de n\oe uds capteurs qui permettent d'effectuer plusieurs expérimentations. Ces n\oe uds ont logiquement besoin d'une base logicielle pour fonctionner, et c'est ici qu'interviennent les firmwares. Il est central dans notre projet de programmer un firmware qui soit efficace et réponde à nos besoins. Pour cela, plusieurs solutions de systèmes d'exploitation disponibles, et présentées sur la plateforme FIT. Il faudra de fait effectuer un choix quant à la solution qui sera employée. Les différents systèmes étudiés peuvent être trouvés sur le site de FIT IoT \footnote{https://www.iot-lab.info/operating-systems/}

\subsection{Contiki}
Contiki est un système d'exploitation open-source, designé pour l'IoT, particulièrement pour la mise en place de protocoles réseaux (TCP/IP, IPv6, Low-Power protocols), reposant sur le système de proto-threads.
\subsubsection{Avantages}
Si nous nous sommes dans un premier temps engoufrés dans la solution Contiki, c'est que pour une première prise en main, la programmation semblait relativement simple.
En effet, la plateforme FIT fournit du code exemple pour chaque système, et Contiki avait la base d'exemples la plus variée. De fait, l'aggragation de deux exemples nous a permis d'arriver à une première solution plutôt acceptable.
\subsubsection{Inconvénients}
En y regardant de plus près, nous avons malheureusement remarqué que dans le cadre des n\oe uds m3, la plateforme Contiki n'a pas de librairie pour la lecture des capteurs de température, qui est une donnée que nous aurions aimé étudier. Par ailleurs, le temps de développement d'une telle librairie étant trop important pour ce genre de projet, nous avons préféré ne pas nous y pencher.
\subsubsection{Ressources d'apprentissage}
Le point de choix principal se trouve au niveau de la facilité d'apprentissage de la plateforme. De fait, la présence de nombreuses ressources est un point central dans le choix d'une technologie.

En l'occurrence, Contiki vient avec des tutoriels de base pour apprendre à compiler du code C en firmware Contiki \footnote{https://www.iot-lab.info/tutorials/contiki-compilation/}. Ce qui le rend plus accessible, c'est surtout ses nombreux exemples qui permettent de rapidement comprendre comment sont programmés les Firmwares sur ce système d'exploitation. 

Deux exemples, particulièrement, sont importants dans notre cas:
Le premier, appelé 01-serial-echo, est un firmware qui, lorsqu'il reçoit un message sur son lien série, renvoie le message sur le lien série, à la manière de la commande echo. Ceci est important pour nous car nous avons besoin de renvoyer les données sur le lien série, ainsi que recevoir par exemple une instruction de capture de données. Cette base de code contient aussi tout ce qui est nécessaire la base des mécanismes évènementiels.

Le second, appelé 03-sensors-collecting, est un firmware qui, à chaque seconde, renvoie sur son lien série les valeurs captées par tous les capteurs définis au préalable. Ici, on obtient donc la base qui permet de capter des données sur les capteurs, ainsi que la manière de mettre un chronomètre en place, ce qui est important pour notre problème.

\subsection{RIOT}
RIOT est un système d'exploitation, qui vise les équipements ayant des ressources minimales, et à donc pour objectif l'efficacité en tous domaines: Énergie, mémoire, modularité...
De même qu'avec Contiki, il est possible d'étudier de nombreux protocoles réseau grâce à ses librairies.
\subsubsection{Avantages}
RIOT vient tout comme Contiki avec une bonne base d'exemples et de tutoriels fournis par FIT IoT pour prendre facilement en main la plateforme. Par ailleurs, RIOT est plus régulièrement mis à jour et maintenu par sa communauté que Contiki.
\subsubsection{Inconvénients}
De prime abord, le code permettant de programmer des firmwares grâce à RIOT semble relativement compliqué. C'est un système qui est plus obscur à comprendre de prime abord, et qui demande donc plus d'investissement pour être maîtrisé
\subsubsection{Ressources d'apprentissage}
Pour la plateforme RIOT, les mêmes tutoriels existent que pour Contiki [5].

Par ailleurs, des exemples permettent aussi de comprendre le fonctionnement global de la plateforme et d'en extraire les principes de base. Malgré cela, il n'existe pas d'exemple traitant directement avec les capteurs, et il nous faut donc aller chercher plus en profondeur dans la documentation pour trouver des solutions à ce niveau.

\subsection{Analyse}
Étant donné le peu d'expertise que nous possédons dans le domaine, nous ne pouvons pas montrer définitivement qu'une solution est meilleure qu'une autre. En effet chacune d'entre elles nous permet à terme d'arriver à une solution très satisfaisante. En effet, le problème de base, au niveau du firmware, est relativement élémentaire et ne demande pas de programmation très compliquée.

Contiki, de ce fait, nous a semblé être une solution idéale pour avancer rapidement dans le problème et le résoudre efficacement.


\section{Base de données temporelle}

\subsection{Présentation}

Une fois la collecte de données automatisée, nous aurons des données horodatées mais il reste néanmoins la question d'où stocker ces données.
Afin de mener le projet au bout, nous aurons besoin d'une base de données temporelle. En effet, celle-ci est indispensable pour stocker des données horodatées, non-relationnelles (mesures indépendantes les unes des autres), avec peu d'attributs et sur un grand volume.


\subsection{Analyse}

Tout d'abord, quelles sont les caractéristiques propres à une base de données temporelle? Les Time Series Databases (notées TSDB) ont besoin d'un horodatage sur les données avec une proximité physique si l'horodatage est proche, les données sont à proximité afin de traiter celles-ci plus efficacement. Ensuite, elles se doivent d'exécuter des "range queries" rapidement, c'est à dire des requêtes rapportant toutes les données inférieures ou supérieures à une condition (ici la condition la plus utilisée sera le temps). Les TSDB se doivent d'obtenir une rapidité d'écriture élevée sur la base puisqu'elle sera remplie fréquemment, elles doivent donc rester le plus possible disponible afin d'éviter de perdre des données. En plus de ces aspects techniques, la TSDB choisie devra avoir une communauté active pour considérer qu'elle est fiable et qu'il y a de la documentation autour ou de l'aide communautaire pour maintenir la solution dans le temps.
Pour évaluer ces différents points, nous nous sommes référés à deux benchmarking fait en 2017 [6] et en 2019 [7].
\newline
Dans le premier benchmarking [6], il se concentre sur un aspect 'features' des bases de données, à savoir qu'elles caractéristiques ont-elles. Celui-ci pointe plusieurs aspects à savoir :
\begin{itemize}
   \item Distribution/Clusterability : disponibilité, extensibilité, et un équilibreur de charge
    \item Functions : fonctions disponibles dans le système MIN/MAX/SUM
    \item Tags : contient un LTS (long time storage), possibilité d'avoir plusieurs horodatages sur une même valeur.
    \item Granularity : décrit le plus petit délai possible entre deux horodatages
    \item Interfaces and Extensibility : les APIs et plugins possibles
    \item Support and License : la propriété intellectuelle de la TSDB et son support commercial
\end{itemize}
Ce rapport montre qu'aucune base de données ne peux implémenter toutes les fonctionnalités existantes sur les TSDBs. Néanmoins, elle montre plusieurs avantages sur certaines TSDBs et leurs inconvénients.
\newline
Pour recentrer les recherches sur la solution à choisir nous avons donc pris en compte le classement de popularité des bases de données fait par db-engines (figure \ref{fig:rankingTSDB}) [8]. Celui-ci permet d'avoir une vision sur les bases qui sont très utilisées, mises à jour et donc actives.

\begin{figure}[h]
    \includegraphics[width=0.6\textwidth]{Images/rankingTDSB}
    \caption{Classement d'activité sur les bases de données temporelles}
    \label{fig:rankingTSDB}
\end{figure}


Celles qui ressortent sont InfluxDB, KDB+ et Prometheus. InfluxDB étant loin devant les autres TSDBs.
\begin{itemize}
	\item InfluxDB est une TSDB open-source qui a été conçue pour stocker et superviser ses données événementielles, en temps réel et est orientée IoT avec beaucoup de possibilités de visualisation.
	\item KDB+ est orienté aussi IoT et accentue son avantage sur la rapidité d'entrées / sorties de sa solution permettant de s'adapter aux besoins de grandes infrastructures industrielles.
	\item  Prometheus est open-source et propose des outils de visualisation et des requêtes simplifiées afin d'accéder aux données et un système d'alertes avancé.
\end{itemize}

Afin d'affiner notre choix, nous avons pris en compte le deuxième benchmarking [7] qui se concentre sur des scénarios IoT et donc prend en compte la performance sur des requêtes SQL particulières, le volume de données utilisé pour une entrée ainsi que le nombre d'entrées possibles/sorties en même temps afin de savoir si la base de données à une bonne capacité d'écriture et de lecture. Néanmoins sur cette étude, on ne distingue pas d'exemple de données, il est discuté de données "générées" néanmoins dans un cadre IoT. 

\begin{figure}[htp]
    \includegraphics[width=0.5\textwidth]{Images/queryRankingTSDB2}
    \caption{Temps de réponse moyen en fonction de la charge [7]}
    \label{fig:courbes}
\end{figure}
Sur ces graphiques (figure \ref{fig:courbes}), on observe le coût en temps de la requête en fonction du nombre d'entrées sur cette dernière.
Lors de ce benchmarking, on peut observer qu'InfluxDB en rouge) [9] est nettement en avance sur les autres TSDBs. Puisque le temps de réponse de celle-ci est bien inférieur aux différentes requêtes est bien inférieur. Là ou elle est moins performante est sur le "SELECT *" (All data query - c), or dans notre cas, les tables seront très courtes (une à deux données max par tables). C'est pourquoi notre premier choix technique se basera sur cette base de données. Néanmoins nous gardons à l'esprit d'autres possibilités de TSDBs, il sera donc important dans la partie conception de bien prendre en compte une certaine facilité à changer de TSDB si nécessaire. De plus, il n'est pas impossible par la suite de changer vers Prometheus [10] étant une TSDB déjà utilisée pour certains projets Fit IoT Lab.

\section {Automatisation via Linux}

	Cette partie vise à déterminer quelles solutions existent sous Linux pour réaliser une tâche automatique comme l'exécution d'un script python qui est notre objectif
	
	\subsection{Cron}
	Cron ou crontab est un daemon linux qui dérive de "chrono table" en anglais. Celui-ci permet de lancer une tâche en arrière plan via un système simple. Pour exécuter une tâche crontab, il suffit d'éditer un fichier via la commande "crontab -e" et y mettre : un motif d'exécution horaire et notre commande. Par exemple, la ligne suivante : "0 */2 * * * python exemple.py" signifie qu'on exécute le script exemple.py toutes les 2 heures.
	
	\subsection{Systemd}
	Systemd est un système d'initialisation et un daemon linux. Il permet aussi d'automatiser les tâches sous la forme de services. Ainsi on peut lancer, arrêter, relancer le service si besoin. Pour la configuration, on utilise deux fichiers pour configurer respectivement : le temps auquel la tâche va s'exécuter et la tâche en elle même avec son environnement.
	
	\subsection{Comparaison}
	Systemd et cron sont deux solutions possibles pour notre script python. L'avantage de systemd est le fait qu'il soit plus complet et que plusieurs tâches peuvent être aisément exécutées et débuggées en même temps. Néanmoins, il introduit plus de complexité avec son système de fichiers, là où crontab ne nécessite qu'une ligne dans un script. Par ailleurs, crontab à un système de mail qui peut nous alerter si une tâche ne s'est pas effectuée correctement. Ainsi, étant donné que nous n'avons qu'une tâche à effectuer, il semble approprié de déployer crontab plutôt que systemd. Néanmoins, si par la suite, dans les évolutions futures de la solution, il était nécessaire d'avoir des scripts différents pour obtenir des relevés différents, nous recommanderions alors d'utiliser systemd. 
	
\section{Protocole RPL}

RPL (Routing protocol for Low-power and Lossy networks)), est un protocole de routage qui est adapté à l'IoT, défini dans la RFC 6550 [11]. Basé sur un système d'arbre de routage, ce protocole exploite deux types de n\oe uds: Dans le réseau, un client est désigné comme étant routeur de bordure. Ce routeur aura pour tâche de renvoyer les paquets remontant vers lui vers la branche qu'il faut. Les autres clients seront alors de simples clients qui renverront leurs paquets vers leur père dans la hiérarchie de l'arbre.

Nous nous basons sur une version basique de RPL, mais il existe des améliorations à ce protocole qui ont été proposées. Nous pouvons par exemple évoquer les améliorations apportées par M. Brandon FOUBERT, que l'on peut retrouver dans l'article suivant [12], dont il a présenté les principes et les résultats lors des journées RSD organisées à Nantes, auxquelles nous avons pu assister dans le cadre de la formation.

Dans notre optique d'analyser l'influence de l'activité humaine dans une plateforme telle que celle de FIT, nous avions besoin d'un protocole de routage léger qui soit facilement implémentable, étant donné le peu de temps qu'il nous restait pour travailler dessus. Par ailleurs, il devait être adapté aux réseaux mobiles, et avoir de potentielles problèmes.

RPL est un protocole qui remplit toutes ses caractéristiques. Étant déjà implémenté dans Contiki, sous FIT IoT lab , nous n'avons quasiment pas de temps de développement à prendre en compte. Par ailleurs, RPL est très sensible à des pertes de paquets, ce qui nous permet d'exploiter une solution qui puisse avoir des soucis en cas de bruit sur la plateforme.

\section{Métriques réseau sur le bruit et qualité}

Concernant la partie réseau, il nous fallait une métrique qui nous permettrait d'évaluer la qualité du réseau, ainsi que le bruit ambiant. Nous avons découvert trois métriques différentes, qui pourraient être acceptables dans notre sujet et qui permettent de faire ces deux choses. Il existe probablement d'autres indicateurs permettant de récupérer ces informations, mais nous avons préféré nous concentrer sur les trois suivantes:

\begin{itemize}
		\item Le LQI: Link Quality Indicator
		\item L'ETX: Expected transmission count
		\item Le RSSI: Received Signal Strength Indication
	\end{itemize}
	
Nous allons donc par la suite les présenter puis expliquer notre choix

\subsection{R-ED - Reciever ED}
Sur cette notion se base deux des prochaines métriques, et il nous faut donc succinctement la présenter ici. C'est une estimation de la puissance du signal reçu dans la bande de fréquence du canal en question. Cette estimation est indépendante des données reçues et ne doit jamais lire les données en question. C'est une notion définie dans la RFC 802.15.4 [13], et dont on peut retrouver une définition dans cette référence [14], à la page 402.

\subsection{LQI: Link Quality Indicator}

Le LQI est un indicateur de qualité de lien. En se basant sur le R-ED ou sur une estimation du rapport signal / bruit, l'implémentation décidée par les constructeurs renvoie une valeur entre 0 et 255. Cette valeur est alors une estimation de la qualité ou de la force du lien entre deux noeuds, pour un paquet donné. Une valeur de 0 correspond à un lien inutilisable, là ou une valeur de 255 indique un lien parfait. Cette valeur est définie dans la RFC 802.15.4 [13] [14]

\subsection{ETX: Expected transmission count}

L'ETX est une métrique permettant de déterminer la qualité d'un chemin entre deux noeuds, dans un réseau sans-fil.
Le calcul est relativement simple, c'est le nombre d'envois de paquets nécessaire pour recevoir un certain nombre de paquets sans aucune erreur. Par exemple, si l'on veut transmettre 1000 paquets, et qu'il nous faut 2000 transmissions pour tout transmettre sans erreur, alors la valeur de l'ETX est 2000/1000 soit 2. Ainsi un ETX de 1 signifie que l'on a un chemin qui ne pose jamais souci, et cette valeur peut monter jusqu'à l'infini, si par exemple le chemin est rompu. Cette valeur est définie dans l'article suivant [15]


\subsection{RSSI: Received Signal Strength Indication}

Le RSSI est une indication relative de la puissance reçue sur un canal, exprimée en dBm. Cette valeur permet de calculer le bruit ambiant sur un noeud, et ainsi de déterminer l'activité radio ambiante à un moment donné. Cette valeur est relativement simple à récupérer dans FIT, en ajoutant un profil de monitoring à une expérience. Encore une fois ici, il n'existe pas de norme précisant la manière de calculer le RSSI, et l'implémentation est laissée libre au constructeur.

\subsection{Conclusion et choix de métrique}
Notre choix s'est de ce fait finalement porté sur le RSSI, et ce pour plusieurs raisons:
L'implémentation et sa mise en place dans les expériences FIT IoT lab est évidente et rapide. Le besoin de cette métrique étant arrivé relativement tard dans le projet, nous n'aurions pas eu le temps de mettre en place une autre métrique. De ce fait, ce choix s'est naturellement fait directement.
Malgré cela, c'est aussi la valeur qui correspond le plus à notre problématique, et qui nous permet le mieux de trouver une réponse. Bien que les autres métriques nous auraient aussi permis de conclure, nous pensons avoir fait le choix idéal avec cette celle-ci.


\section{Conclusion}


Sur cet état de l'art, nous avons présenté les différents éléments nécessaires à l'implémentation de notre solution à savoir :
	\begin{itemize}
		\item La plateforme FIT IoT Lab
		\item Les firmwares M3
		\item La base de données temporelles
	\end{itemize}
	
Nous avons pu aboutir à une première solution en prenant des choix qui nous semble correct. A savoir le choix de développer sur la plateforme FIT via la frontend SSH afin de ne pas à avoir héberger notre script et directement lancer l'automatisation en local, mettre en place un premier firmware via Contiki puisqu'il offre une simplicité de programmation et déjà une bonne base d'exemple de firmwares et mettre en place dans un premier temps une base de données InfluxDB mais garder à l'esprit de bien compartimenter cette partie afin de ne pas avoir de problèmes d'intégration s'il y a une nécessité de migrer vers un autre type de base de données.



\section{Conclusion}


À l'issue de ce travail de recherche bibliographique, il apparaît que plusieurs propositions peuvent servir de base à la résolution de notre problème.

Il semble se détacher un certain nombre de directions privilégiées que nous allons exploiter en priorité dans nos propositions.

Celles-ci font l'objet de l'étude du chapitre suivant.


\chapter{Conception}
\label{chap:Conception}

Cette partie est dédiée au système dans son ensemble et à la manière dont il a été pensé et conceptualisé. Nous voulons ici présenter les différents systèmes qui composent notre solution, ainsi que les différentes interactions qui les caractérisent. Les diagrammes ont pour but de clarifier le propos et de fluidifier la compréhension.


\section{Scénario - Diagramme de séquence}

Cette section a pour but d?expliquer le fonctionnement de notre script de collecte de données à la fin du projet pour que la partie majoritaire du projet soit réussie. Nous nous sommes penchés sur deux scénarios différents de diagramme de séquence.

\subsection{Scénario A}
Le scénario A (figure \ref{fig:DiagSequenceA}) s'exécute dans la séquence suivante : 
\begin{enumerate}
\item{Le script s'exécute automatiquement à une certaine heure de la journée, vérifie la disponibilité des n\oe uds et réserve un maximum d'entre eux}
\item{Une fois les n\oe uds réservés grâce à l'API REST, ils sont flashés avec le bon firmware et commencent leur capture de données}
\item{Puis on accède directement à un noeud pour faire une demande de données via une entrée prédéfinie. On ré-exécute ceci pour chaque noeud soit séquentiellement, soit via des threads}
\item{Une fois traitées, ces données sont formatées et envoyées vers la Base de données temporelles pour écriture et stockage}
\end{enumerate}

\subsection{Scénario B}
Le scénario B ressemble au scénario A mais il utilise le serial aggregator. Comme décrit dans la partie état de l'art, le serial aggregator permet d'agréger toutes les données reçues par les noeuds M3 en un seul point. Le début et fin du scénario sont donc les mêmes.
Ainsi, la différence décrite dans le diagramme en figure \ref{fig:DiagSequenceB} ) est la suivante:

\begin{enumerate}
\item{Initialisation du script comme précedemment avec flash des noeuds.}
\item{Dès lors, le Serial aggregator commence à écouter les n\oe uds et récupère les données qui lui sont envoyées par lien série. Une fois qu'il a tout reçu, il renvoie ces données au script Python qui les traite.}
\item{Récupération et mise en forme dans la base de données.}
\end{enumerate}

\subsection{Choix}
Le scénario A permet d'avoir un meilleur contrôle sur la captation puisqu'on va directement accéder aux noeuds néanmoins il nécessite une grande synchronisation et beaucoup de connexions en même temps à leurs interface. C'est pourquoi la deuxième approche avec le serial aggregator est préférée dans notre cas. Cela permet une implémentation plus aisée en utilisant les outils déjà développés mais aussi un seul point de sortie pour toutes les données. Le script python va donc être simplifié et plus lisible.


\section{Ensemble du système - Diagramme d'architecture }
Ce diagramme d'architecture (Figure \ref{fig:DiagArchi} ) représente où sont placés les différentes parties prenantes pour l'exécution de la collecte automatique des données. Ainsi que d'un ordre partiel pour comprendre le mécanisme global.
La solution nécessite 2 sites pour fonctionner : Grenoble là où l'API REST est localisé et Lille pour les noeuds M3.
Sur Lille, trois composants sont nécessaires :
	\begin{itemize}
		\item Frontend SSH contenant un compte configuré avec le script DataCollector dessus et le crontab en arrière plan pour l'automatisation.
		\item Testbed de Lille, c'est à dire le bâtiment de Lille contenant tous les noeuds M3.
		\item Seveur Inria, un emplacement pour héberger la base de données.
	\end{itemize}
	
Les différentes étapes de la solution sont :
\begin{itemize}
	\item 1 - Exécution automatique, par le deamon Cron du script DataCollector. Crontab permet de paramétrer une ligne de commande à lancer toutes les X minutes où un schéma horaire particulier. On peut aussi utiliser systemd qui est un autre deamon réalisant la même tâche.
	\item 2 - Exécution de CLI Tools. Le script va faire une succession d'appels à l'API REST pour avoir plusieurs information. Premièrement, prendre l'état du Testbed (combien de noeuds sont disponibles sur la plateforme), puis de lancer l'expérience en fonction avec notre firmware et un profil de monitoring radio. Enfin, attendre que l'expérience lancée soit prête pour démarrer l'étape 5.
	\item 3 - Programmation des noeuds. L'API REST va réserver les noeuds et donner le firmware associé à l'expérience.
	\item 4 - Flash des noeuds. On associe les noeuds à leur firmware, ils vont donc relever 5 données et les envoyer ensuite sur leurs liens séries.
	\item 5 - Lancement Serial Aggregator. Une fois l'expérience prête, on lance le script serial aggregator qui va écouter les liens séries de tous les noeuds d'une expérience.
	\item 6 - Ecoute des liens séries. L'expérience ne dure qu'une minute pour éviter de monopoliser la plateforme FIT de Lille. Au bout de la minute, les connections se ferment à tous les noeuds, ce qui arrête le serial aggregator qui va rassembler toutes les données.
	\item 7 - Ecriture dans la BDD. Le script DataCollector récupère la sortie du serial aggregator et prépare son format pour pousser ses données dans InfluxDB en JSON.
\end{itemize}

\section{Schéma de Base de données}

Nous avons eu deux propositions de schéma de base de données afin de savoir comment mieux représenter les données et leurs utilisations. 

\subsection{Tuple de données}
	La première idée est de faire un tuple de données avec : Noeud, Timestamp, LightValue, PressureValue, RssiValue, RssiChannel. Cela peut paraître à priori une bonne solution contenant toutes les informations d'un noeud à un instant T. Le premier problème est que les données ne sont pas prises au même moment exactement, ce qui signifie que les données RSSI, lumière et pression ne partage pas la même estampille de temps. Sachant que les données seront traitées ensuite par des chercheurs pour entrainer de l'intelligence artificielle, il faut une précision dans les données. De plus, cette façon de conceptualisation revient à un schéma classique de base de données relationnelles. Or dans notre cas, nos données ne sont pas liés exceptés par leur numéro de noeud. Un autre problème qui pourrait arriver dans ce cas là, serait une absence de données sur un instant. Cela peut arriver pour plusieurs raisons: soit le noeud n'a pas été choisi dans l'expérience (ce qui est possible car lors de la soumission, on ne demande qu'un nombre de noeuds et non des noeuds précis) ou alors un problème sur le noeud directement, et ce pour diverses raisons. Nous savons que ceci peut exister puisque certains noeuds sont reconnus pour avoir des problèmes à l'initialisation. 


\subsection{Table par type de données}
Une solution alternative peut être de représenter la base de données avec une table par type de donnée stockée. Cela permet de garder une estampille correcte avec la valeur de donnée associé. Afin de garder le lien entre les données, à savoir le noeud capté, on utilise un "tag" qui représente l'utilisateur de la ressource. Ainsi, toutes les données captés par un noeud M3-1XX seront marquées par ce même nom. On peut ainsi traiter les données sur ce tag. Le système InfluxQL favorise ce schéma puisqu'il est optimisé pour les requêtes InfluxQL (langage SQL pour InfluxDB).
Le schéma de base de données temporelles final reste simple puisqu'il est composé seulement de 3 tables :
	\begin{itemize}
		\item Light, contient les données de lumière en lux
		\item Pressure, contient les données de pression en maBar
		\item RSSI, contient les données radio en dBm
	\end{itemize}


\begin{figure}[h]
    \includegraphics[width=0.5\textwidth]{Images/schema-BDD}
    \caption{Schéma base de données}
\end{figure}

\subsection{Stockage}
Comment InfluxDB stocke t-il ses données ? Celui-ci découpe son organisation en 3 dossiers : 
\begin{itemize}
	\item Meta contient un certains nombre de paramètres et informations utiles : les users, databases existantes, retention policies, shards, and continuous queries. Les retentions policies sont un moyen de définir le recyclage de la base de données, c'est à dire à quelle moment va t-elle supprimer des données ou archiver. Les shards sont la vision d'InfluxDB sur les données, elle groupe les données selon des shards (en général par proximité temporelle) et va les stocker, supprimer, traiter au même endroit. Les continous queries sont un outil permettant de faire des requêtes en continue sur la base.
	\item WAL (Write Ahead Log) est un dossier de cache pour les bases de données.
	\item Data est le dossier contenant les bases de données. Il existe par défaut la base de données internal contenant un certain nombre d'informations générales sur nos bases de données. Puis ensuite, il existe toutes les données relatives à nos collectes.

\end{itemize}


\section{Fréquence de relevé}

	Une fois la solution mise en place de collecte de données, il faut déterminer quand et comment lancer le script. L'exécution se fait par crontab mais combien de noeuds doit on réserver ? A quelle fréquence? Pour le nombre de noeuds réservés, la solution réserve un taux de disponibilité de la plateforme. Par exemple à un instant T, la plateforme dispose de 300 noeuds dont 200 sont disponibles. Si le taux de réservation du script est 50\% alors on réserve 100 noeuds sur Lille. Ainsi on évite de vouloir réserver plus de noeuds que disponible. Ensuite quel taux choisir ? Idéalement 100\% mais cela peut poser problème puisque la plateforme va délayer notre expérience car trop de noeuds seront indisponibles si elle accepte notre expérience. Ainsi nous avons décider arbitrairement de prendre 70\% de la plateforme sur une minute, ce qui limite qu'on affecte trop la disponibilité. Ensuite la fréquence s'effectue toutes les 30 minutes par soucis de disponibilité puisque si on intensifie ses relevés, trop de noeuds seraient indisponibles pour les autres utilisateurs. Mais aussi nous relevons des mesures physiques, or celles-ci ne vont pas avoir d'énormes variations entre plusieurs demi-heures. Par la suite, avec une vision sur plusieurs semaines, la fréquence de relevé pourra être ajusté pour diminuer la volumétrie ou l'augmenter selon les besoins des chercheurs.

\section{Grafana}

	Après la collecte de données, il nous fallait un outil pour la visualisation des données et son exploitation. C'est pourquoi nous avons choisi Grafana qui est un outil web permettant de facilement intégrer les données InfluxDB via une interface web avec un vue simplifiée. Une vue classique de nos données peut se représenter ainsi : figure \ref{fig:Grafana_example}
	

\begin{figure*}[!ht]
	\centering
    \includegraphics[width=1.1\textwidth]{Images/grafana}
    \caption{Exemple de visualisation des données captées - 02/02/2020}
    \label{fig:Grafana_example}
\end{figure*}


\begin{figure*}[!ht]
    \includegraphics[width=1\textwidth]{Images/diagrammeArchi-v2}
    \caption{Diagramme d'architecture}
    \label{fig:DiagArchi}
\end{figure*}

\begin{figure*}[!ht]
	\centering
	\includegraphics[width=0.9\textwidth]{Images/diagseq2}
	\caption{Diagramme de séquence scénario A}
	\label{fig:DiagSequenceA}
\end{figure*}

\begin{figure*}[!ht]
	\centering
	\includegraphics[width=0.8\textwidth]{Images/diagseq}
	\caption{Diagramme de séquence scénario B}
	\label{fig:DiagSequenceB}
\end{figure*}

%-------------------------------------------------------------------------------------------------------------

% \part{Réalisations} % À décommenter si l'état de l'art a nécessité plusieurs chapitres.
% \label{part:Realisations}

\chapter{Expérimentations et résultats}
\label{chap:Experimentations}

S'agissant d'un travail de recherche \emph{et} de \emph{développement}, une production de code source est très certainement présente.
Auquel cas, le chapitre va commencer par une section sur le produit développé.

\begin{structuration}
Soulignons que, comme dans le chapitre précédent, si le volume de ce chapitre devient très important, il est préférable de le transformer en partie de rapport, les sections suivantes devenant des chapitres, et ainsi de suite pour les parties hiérarchiquement inférieures.
\end{structuration}

\section{Script de collection de données}

\subsection{Développements}
	La solution de collecte de données (DataCollector) est totalement implémentée dans la plateforme FIT IoT Lab. Celle-ci respecte le schéma d'architecture \ref{fig:DiagArchi} et diagramme de séquence \ref{fig:DiagSequenceB}. 
	
\subsection{Expérimentations}

Nous avons fait plusieurs expériences pour mesurer le RSSI qui posait certains problèmes d'irrégularités \ref{fig:bugRSSI} .
Dans un premier temps, nous nous sommes penchés sur comment le RSSI était pris dans nos mesures. Il s'avère qu'une mauvaise valeur était retournée mais il restait une chose étrange à savoir que les canaux était tous passifs (-91 dBm constant) excepté le premier. Dans cette démarche nous avons essayé de savoir si notre code était encore en défaut ou si l'utilisation d'un "monitor profile" (outil fourni par FIT pour capter les canaux radios) posait un problème d'implémentation.
Il s'avère que notre problème n'était pas dans ces 2 propositions mais venait de la fréquence de relevé d'expérimentation. En effet, la communication radio étant de l'ordre d'une dizaine de micro-secondes et notre période de 4s, il y avait un problème d'échelle. C'est pourquoi en intensifiant les relevés en dizaine de millisecondes, on retrouve des valeurs fluctuant sur tous les canaux.

\begin{figure}[htp]
    \includegraphics[width=0.50\textwidth]{Images/rssi_bug}
    \caption{Grafana - Bug sur le RSSI}
    \label{fig:bugRSSI}
\end{figure}

\subsection{Résultats}

Via Grafana, on peut visualiser nos différentes données à savoir :
\begin{itemize}

 \item Lumière: figure \ref{fig:lumiere} .
 \begin{figure}[htp]
    \includegraphics[width=0.50\textwidth]{Images/grafana_light}
    \caption{Grafana - captation lumière 29-31/01/2020}
    \label{fig:lumiere}
\end{figure}
 La lumière est mesurée en lux. Une première chose intéressante qu'on peut remarquer est le fait qu'on observe des pics de lumières vers 6H, ce qui équivaut aux agents d'entretiens du bâtiment puis que la lumière monte globalement au cours de la journée.
 
\item Pression:  figure \ref{fig:pression} .
\begin{figure}[htp]
    \includegraphics[width=0.50\textwidth]{Images/grafana_pressure}
    \caption {Grafana - captation pression 29-31/01/2020}
    \label{fig:pression}
\end{figure}
La pression est en mBar. On peut observer que la pression atmosphérique est globalement la même pour tous les noeuds mais qu'il reste des variations. De plus on observe des lignes ne respectant pas la tendance globle qui sont dues à une absence de données de ses capteurs pendant le relevé, par exemple à cause d'une autre réservation de quelqu'un.

\item RSSI:  figure \ref{fig:rssi}.
\begin{figure}[htp]
    \includegraphics[width=0.50\textwidth]{Images/grafana_rssi2}
    \caption{Grafana - captation rssi 29-31/01/2020}
    \label{fig:rssi}
\end{figure}
Le RSSI est complexe à mesurer puisque, comme dit précédemment, la fréquence de mesure influe sur ce qu'on va obtenir. Mais il est impossible de mettre une fréquence trop élevée comme 1 ms puisque cela augmenterait considérablement la taille des données. L'astuce utilisée est de mettre une fréquence assez faible (environ 10 ms) et de supprimer les fréquences à -91dbm lorsqu'il n'y a pas d'activité radio. C'est à dire que dès lors qu'il y a un changement de RSSI, celui ci va enregistrer son entrée mais aussi l'entrée précédente et future. Ainsi dès que deux valeurs consécutives de RSSI sont à -91dBm (équivaut à aucune activité radio particulière), on efface la donnée pour limiter un nombre très important de points non intéressant.

\begin{figure}[htp]
    \includegraphics[width=0.50\textwidth]{Images/grafana_rssi2}
    \caption{Grafana - captation rssi channel 11 08/02/2020-14:00:26 à 14:00:32}
    \label{fig:rssi}
\end{figure}

Une vue par noeud \ref{fig:rssiM3} est mise aussi en place pour pouvoir mieux visualiser les valeurs de RSSI étant très rapprochées sur une petite période.

\begin{figure}[htp]
    \includegraphics[width=0.50\textwidth]{Images/grafana_rssi3}
    \caption{Grafana - captation rssi channel 11, noeud m3-104, 08/02/2020-14:00:26 à 14:00:32}
    \label{fig:rssiM3}
\end{figure}

\end{itemize}



\section{Reproductibilité du protocole RPL}

\subsection{Développements}
Cette partie est sûrement l'une de celles qui aura demandé le moins de développement. En effet, le protocole RPL possède déjà une implémentation dans FIT IoT lab, sous la technologie Contiki.

Par ailleurs, les différents scripts permettant d'affecter des préfixes IPv6 ou de regarder la topologie de l'arbre RPL créé sur chaque n\oe ud est déjà fournie par la plateforme FIT. Il n'y a donc pas eu de développement quant à ces questions ci.

Le plus important a donc été la manière de penser cette expérience et de la designer afin qu'elle puisse nous apporter des solutions qui soient exploitables


\subsection{Expérimentations}

Nous utilisons donc le système d'expériences de FIT IoT Lab pour réserver 30 n\oe uds m3 sur la plateforme. Ces n\oe uds se doivent d'être assez proches afin que RPL puisse en router un maximum dans un arbre de routage. Dans ses 30 n\oe uds, on en sélectionne un (Si possible toujours le même), qui sera alors le routeur de bordure, c'est à dire la racine de l'arbre défini par RPL. Les autres n\oe uds sont de simples clients qui sont chargés de générer du trafic en temps normal (Ici, ils ne font que se router)

Dès que l'expérience est démarrée, nous affectons un préfixe IPv6 aux n\oe uds que nous avons réservés grâce à la frontale SSH. Sur cette même frontale, nous vérifions alors le bon établissement de l'arbre de routage RPL. Dès que la solution a convergé, on note le temps que l'expérience a pris et on recommence.

La difficulté vient avant tout du fait que cette expérience n'est qu'assez peu reproductible. En effet, à chaque fois que l'on recommence, la topologie de l'arbre est différente, certains n\oe uds ne rentrent pas dans l'arbre etc..

\subsection{Résultats}

Malheureusement, et étant donné le court temps que nous avons eu pour effectuer ces expériences, les données récoltées ne nous ont pas permis de conclure. En effet, si pour un petit nombre de n\oe uds, RPL se comporte très bien, ce n'est pas le cas pour un nombre plus grand de cartes. Plusieurs essais à 30 n\oe uds, à des periodes durant lesquelles la plateforme Lilloise n'était pas utilisée, RPL n'a jamais réussi à connecter les 30 n\oe uds dans un seul arbre. Le maximum de connexions que nous avons obtenu était 14, ce qui est trop faible pour estimer cette expérience comme une réussite. Toutes les autres tentatives se sont soldées par des échecs avec des arbres d'une taille de 8 à 10 n\oe uds.

Avec plus de temps nous aurions pu nous pencher plus en avant sur les raisons de ces échecs, qui existent forcément puisque plusieurs personnes ont déjà utilisé RPL sur FIT IoT lab sans que cela pose de soucis. 


\chapter{Planification}

Cette partie inclut des graphiques relatifs à notre travail. Nous avons découpés nos tâches en 5 catégories :
\begin{itemize}
	\item Tutoriel FIT IoT Lab
	\item Recherches bibliographiques
	\item Développement Firmware/Python
	\item Rédaction de rapport, bilan de réunions,...
	\item Contact : les réunions et appels
\end{itemize}

Dans l'ensemble, l'estimation de nos tâches ont étés proches de la réalité mais nous avons globalement sous-estimé les heures nécessaires pour réaliser notre travail. Nous avons donc dû augmenter nos horaires sur certaines semaines plus libres que d'autres. Cela nous a permis de nous reconcentrer sur des petites tâches comme conseillé par Julien Vandaele pour obtenir une démo pour la première période (7 octobre 2019 - 01 décembre 2019).


\newpage
La deuxième période présente plus de développement afin de finaliser la solution de collecte automatique. Puis quelques recherches bibliographiques et expérimentations pour compléter notre maitrise du protocole RPL. Nous avons eu un gros contre temps avec l'automatisation du script qui présentait pas mal de difficultés d'implémentation au sein de la plateforme FIT.

\newpage
\begin{figure}[htp]
    \includegraphics[width=0.40\textwidth]{Images/tempsTache_p1}
    \caption{Temps par catégorie de tâche - période 1}
\end{figure}

\begin{figure}[htp]
    \includegraphics[width=0.355\textwidth]{Images/repartitionTache_p1}
    \caption{Répartition du temps par catégorie - période 1}
\end{figure}


\begin{figure}[htp]
    \includegraphics[width=0.45\textwidth]{Images/tempsTache_p2}
    \caption{Temps par catégorie de tâche - période 2}
\end{figure}

\begin{figure}[htp]
    \includegraphics[width=0.45\textwidth]{Images/repartitionTache_p2}
    \caption{Répartition du temps par catégorie - période 2}
\end{figure}

\begin{figure*}
   \centering
          \includegraphics[width=1.15\textwidth]{Images/ganttTache_p1}
   \caption{Planning effectif - période 1}
   \label{fig:PlanningEffectif}
\end{figure*}

\begin{figure*}
   \centering
          \includegraphics[width=1.15\textwidth]{Images/ganttTache_p2}
   \caption{Planning effectif - période 2}
   \label{fig:PlanningEffectif}
\end{figure*}




\chapter{Fiches de suivi}
\label{ann:FichesSuivi}

Cette annexe est \emph{obligatoire}.

\begin{fichesuivi}{7 Octobre 2019}{13 Octobre 2019}
   \tempstravailA{6}{30}
   \tempstravailB{5}{30}

   \begin{travaileffectue}
      \begin{itemize}
         \item Prise de connaissance du sujet
         \item Prise en main de la plateforme FIT IoT lab
         \item Premiers contacts avec le commanditaire - encadrant
         \item Début de recherches bibliographiques
      \end{itemize}
   \end{travaileffectue}

   \begin{travailnoneffectue}
   \end{travailnoneffectue}

   \begin{echange}
      \begin{itemize}
         \item Demande d'informations auprès de Julien Vandaele
         \begin{itemize}
         \item Précisions du sujet et questions générales
         \item Début de reformulation du sujet
         \end{itemize}
      \end{itemize}
   \end{echange}

   \begin{planification}
      \begin{itemize}
         \item Travail plus profond sur le sujet - Recherche de problématique
         \item Recherches bibliographiques
         \item Prise en main de la plateforme FIT IoT lab
      \end{itemize}
   \end{planification}
\end{fichesuivi}

\begin{fichesuivi}{14 Octobre 2019}{20 Octobre 2019}
   \tempstravailA{11}{00}
   \tempstravailB{11}{00}

   \begin{travaileffectue}
   \begin{itemize}
   \item Documentation sur la plateforme FIT
   \begin{itemize}
   		\item{Nodes M3}
   		\item{Tutoriels FIT IoT lab}
   		\item{API REST FIT IoT lab}
   \end{itemize}
   \item{Début de tests de code sur l'API REST de FIT IoT lab}
   \item{Début de rédaction de rapport - Introduction}
   \item{Prise en main d'InfluxDB}
   \end{itemize}
   \end{travaileffectue}

   \begin{travailnoneffectue}
   \end{travailnoneffectue}

   \begin{echange}
   \begin{itemize}
   \item{Mails de présentation et précisions du sujet par mail}
   \end{itemize}
   \end{echange}

   \begin{planification}
   \begin{itemize}
   \item{Continuation des recherches bibliographiques}
   \item{Tutoriels FIT IoT lab}
   \item{Rédaction de l'introduction du rapport}
   \item{Visioconférence}
   \end{itemize}
   \end{planification}
\end{fichesuivi}

\begin{fichesuivi}{21 Octobre 2019}{27 octobre 2019}
   \tempstravailA{5}{30}
   \tempstravailB{5}{30}

   \begin{travaileffectue}
   \begin{itemize}
   \item{Visioconférence avec Julien Vandaele, qui aura permis de finalement délimiter le sujet et lui donner un cadre précis}
   \item{Tutoriels FIT IoT lab: SSH / Build firmwares}
   \item{Début de rédaction du rapport de réunion pour rendu la semaine prochaine}
   \end{itemize}
   \end{travaileffectue}
	
   \begin{travailnoneffectue}
   \begin{itemize}
   \item{Plus de tutoriels}
   \item{Rédaction du rapport}
   \item{Lectures bibliographiques}
   \item{Tout ce travail n'ayant pas été effectué à cause d'une semaine chargée}
   \end{itemize}
   \end{travailnoneffectue}

   \begin{echange}
   \begin{itemize}
   \item{Visioconférence}
   \end{itemize}
   \end{echange}

   \begin{planification}
   \begin{itemize}
   \item{Lectures bibliographiques / Étude de la plateforme FIT IoT}
   \begin{itemize}
   \item{Impact de la présence humaine sur divers protocoles}
   \item{Tutoriels FIT IoT lab}
   \end{itemize}
   \item{Début de programmation d'un firmware de test}
   \end{itemize}
   \end{planification}
\end{fichesuivi}

\begin{fichesuivi}{28 Octobre 2019}{3 Novembre 2019}
   \tempstravailA{3}{30}
   \tempstravailB{3}{30}

   \begin{travaileffectue}
   \begin{itemize}
   \item{Début de listing des possibilités pour les Systèmes de bases de données temporelles}
   \end{itemize}
   \end{travaileffectue}

   \begin{travailnoneffectue}
   \begin{itemize}
   \item{Travail bibliographique}
   \item{Etude de la plateforme FIT IoT lab}
   \end{itemize}
   \end{travailnoneffectue}

   \begin{echange}
   \end{echange}

   \begin{planification}
   \begin{itemize}
   \item{Rattrapage du travail non effectué lors des deux dernières semaines}
   \begin{itemize}
   \item{Recherches bibliographiques}
   \item{Etude de la plateforme FIT IoT lab}
   \end{itemize}
   \item{Listing et choix d'une base de données idéale}
   \item{Début de travail sur un premier firmware pour expériences sur capteurs}
   \end{itemize}
   \end{planification}
\end{fichesuivi}

\begin{fichesuivi}{4 Novembre 2019}{10 Novembre 2019}
   \tempstravailA{15}{00}
   \tempstravailB{15}{00}

   \begin{travaileffectue}
   \begin{itemize}
   \item{Etat de l'art sur les bases de données temporelles}
   \begin{itemize}
   \item{Préparation d'une présentation de solutions}
   \end{itemize}
   \item{Diagrammes de séquence pour s'assurer de la marche à suivre pour le développement}
   \item{Etude des noeuds M3}
   \item{Début de développement d'une démonstration simple de script de collecte de bases de données}
   \end{itemize}
   \end{travaileffectue}

   \begin{travailnoneffectue}
   \end{travailnoneffectue}

   \begin{echange}
   \begin{itemize}
   \item{Échanges autour de la séquence d'expérimentation, précisions finales du sujet}
   \end{itemize}
   \end{echange}

   \begin{planification}
   \begin{itemize}
   \item{Réunion prévue le 12/11 à 15h}
   \item{Rédaction du rapport}
   \item{Développement du script suivant le scénario}
   \item{Recherches bibliographiques centrées sur l'intéraction Humains/réseaux wireless}
   \end{itemize}
   \end{planification}
\end{fichesuivi}

\begin{fichesuivi}{11 Novembre 2019}{17 Novembre 2019}
   \tempstravailA{10}{00}
   \tempstravailB{9}{00}

   \begin{travaileffectue}
   \begin{itemize}
   \item{Suite de l'état de l'art sur les bases de données temporelles}
   \item{Rédaction du rapport}
   \begin{itemize}
   \item{Rédaction de l'état de l'art sur les bases de données}
   \item{Présentation de la plateforme FIT IoT lab}
   \end{itemize}
   \item{Développement de script suivant le scénario}
   \begin{itemize}
   \item{Diagrammes de séquencevalidés par le commanditaire et les encadrants}
   \end{itemize}
   \item{Recherches bibliographiques centrées sur l'intéraction humains/réseaux wireless}
   \begin{itemize}
   \item{Ces recherches n'ont pas été pertinentes puisqu'aucun article en lien avec notre problématique n'était dans le sujet. Par ailleurs, cette question ne sera traitée que bien plus tard, il n'était donc pas nécessaire d'investir du temps dès maintenant sur le sujet}  
   \end{itemize}
   \item{Tutoriel sur le développement de firmwares}
   \begin{itemize}
   \item{Tutoriel Contiki}
   \item{Tutoriel de départ}
   \end{itemize}
   \end{itemize}
   \end{travaileffectue}

   \begin{travailnoneffectue}
   \end{travailnoneffectue}

   \begin{echange}
   \begin{itemize}
   \item{Réunion le 12/11 (1h30)}
   \begin{itemize}
   \item{Présentation de l'état de l'art sur les BDD temporelles}
   \item{Reformulation et recentrage sur les besoins du projet}
   \item{Projet abordé de façon plus agile que normalement}
   \item{Attendus pour la prochaine réunion (Présentation Powerpoint pour la soutenance, Rapport, étape firmware)}
   \end{itemize}
   \end{itemize}
   \end{echange}

   \begin{planification}
   \begin{itemize}
   \item{Poursuite de la découverte des tutoriels firmware en réalisation d'une première réalisation de firmware (développement C}
   \item{Etat de l'art sur les différentes plateformes de développement des firmware}
   \item{Apprentissage d'une librairie Python en vue d'une utilisation de SSH pour se connecter sur FIT IoT lab}
   \end{itemize}
   \end{planification}
   
\end{fichesuivi}
\begin{fichesuivi}{17 Novembre 2019}{24 Novembre 2019}
   \tempstravailA{17}{00}
   \tempstravailB{19}{00}

   \begin{travaileffectue}
   \begin{itemize}
   \item{Développement Firmware}
   \begin{itemize}
   \item{Recherche dans les firmwares exemple existant afin de déterminer si certains sont liés à notre problème}
   \item{Analyse du code des firmware existants}
   \item{Installation de l'environnement de travail en local}
   \item{Début de programmation d'un firmware maison}
   \end{itemize}
   \item{Python SSH}
   \begin{itemize}
   \item{Recherche de différents packages existants pour utiliser SSH en python (Paramiko - Fabrik - Quelles différences? - Que choisir ?)}
   \item{tutoriels sur les packages en question}
   \item{Premier test de connexion SSH sur FIT via Python}
   \item{Scénario basique de l'algorithme}
   \end{itemize}
   \end{itemize}
   \end{travaileffectue}

   \begin{travailnoneffectue}
   \end{travailnoneffectue}

   \begin{echange}
   \begin{itemize}
   \item{Bilan de réunion du 12/11}
   \end{itemize}
   \end{echange}

   \begin{planification}
   \begin{itemize}
   \item{Python SSH}
   \begin{itemize}
   \item{Ecrire la liste des commandes SSH à réaliser}
   \item{Commencer à intégrer le scénario dans Python}
   \end{itemize}
   \item{Finition du firmware maison objectif pour la réunion de la semaine suivante}
   \end{itemize}
   \end{planification}
\end{fichesuivi}

\begin{fichesuivi}{24 Novembre 2019}{01 Décembre 2019}
   \tempstravailA{28}{0}
   \tempstravailB{25}{0}

   \begin{travaileffectue}
   \begin{itemize}
   
   	\item  Développement Firmware
   		\begin{itemize}
   			\item Développement, test et debug du firmware Sur Contiki
   			\item Intégration au code de Pierre-adrien
   			\item Début de tests sur RIOT
   		\end{itemize}
   
   	\item  Python SSH 
   		\begin{itemize}
   			\item Dev Fabric Python 
   			\item => Méthode python SSH avortée (voir échange avec le commanditaire)
   		\end{itemize}

	\item  Frontend SSH 
   		\begin{itemize}
   			\item Librairie subprocess / os 
   			\item Dev subprocess => exécution de commande bash
   			\item Format des données
   		\end{itemize}
   		
   	\item  Rédaction du rapport 
   		\begin{itemize}
   			\item Introduction 
   			\item Etat de l'art : mise en forme
   			\item Conception
   			\item Autres
   		\end{itemize}
   		
\end{itemize}
   

   \end{travaileffectue}

   \begin{travailnoneffectue}
   \end{travailnoneffectue}

   \begin{echange}
   \begin{itemize}
   	\item Discussion Python SSH
   	
   	Julien a fait une remarque sur Python SSH ne voyant pas l'utilité de celui-ci. Notre point de vue était de réaliser le script python en local puis se connecter en SSH par la suite sur le frontend SSH afin de lancer les commandes pour lancer l'expérience, récolter les coordonnées,... La vision de Julien est de mettre le script directement sur le frontend SSH pour ne pas avoir à l'héberger par la suite. Ainsi aucune connexion SSH serait nécessaire.
=> Le développement sur le frontend SSH a abouti en utilisant la librarie os, subprocess pour lancer les commandes
 
 
   	\item Librairie manquante pour l'exploitation du capteur de température des noeuds m3 en contiki
\begin{itemize}
\item Librairie manquante pour l'exploitation du capteur de \item Possibilité que cela existe en contiki-ng
\item Besoin potentiel de créer ce code
\item Ou de changer de solution (Riot par exemple)
\end{itemize}   	 


\end{itemize}   

   \end{echange}

   \begin{planification}
   \begin{itemize}
   \item Développement Démo 
   	\begin{itemize}
   	 \item Ajouter de la généricité pour le script
   	 \item Automatiser le script
   	\end{itemize}
   	\item Firmware RIOT
   	\item Préparation soutenance
   \end{itemize}




   \end{planification}
\end{fichesuivi}

\begin{fichesuivi}{01 Décembre 2019}{08 Décembre 2019}
   \tempstravailA{11}{30}
   \tempstravailB{8}{0}

   \begin{travaileffectue}
      \begin{itemize}
   		\item Développement de la démonstration pour la soutenance
   		\item Développement avec Crontab pour automatiser le lancement des scripts afin de collecter automatiquement les données
	\item Suite du développement du Firmware avec RIOT
	\item Préparation de la présentation
   		
		\end{itemize}
   \end{travaileffectue}

   \begin{travailnoneffectue}
   \end{travailnoneffectue}

   \begin{echange}
   	\begin{itemize}
   	\item Présentation des slides et pré-soutenance
   	\end{itemize}
   \end{echange}

   \begin{planification}
   \begin{itemize}
   	\item Finalisation de la présentation
   	\item Continuer le développement de l'automatisation
   	\item Fin des tests et du développement sur RIOT
   \end{itemize}
   \end{planification}
\end{fichesuivi}

\begin{fichesuivi}{8 Décembre 2019}{15 Décembre 2019}
   \tempstravailA{11}{0}
   \tempstravailB{11}{0}

   \begin{travaileffectue}
   	\begin{itemize}
   		\item Présentation de la présentation pour la soutenance
   		\item Recherches dans contiki-ng
   		\item Modules de BDD
   		\item Soutenance intermédiaire
   	\end{itemize}
   \end{travaileffectue}

   \begin{travailnoneffectue}
   \end{travailnoneffectue}

   \begin{echange}
   \begin{itemize}
   	\item Questions à propos de l'hébergement de la BDD
   \end{itemize}
   \end{echange}

   \begin{planification}
   	\begin{itemize}
   	\item Redéfinir un sujet sur quant à l'aspect recherche du projet
   	\item Continuer l'intégration à la base avec l'hébergement à trouver
   	\item Rechercher dans RIOT la librairie traitant du capteur température puisque absent dans Contiki-NG
   	\end{itemize}
   \end{planification}
\end{fichesuivi}

\begin{fichesuivi}{15 Décembre 2019}{22 Décembre 2019}
   \tempstravailA{5}{0}
   \tempstravailB{5}{0}

   \begin{travaileffectue}
    \begin{itemize}
   		\item Première estimation du dimensionnement de la base de données
   		\item Prise en compte du RSSI dans la solution de captation automatique de données
   	\end{itemize}
   \end{travaileffectue}

   \begin{travailnoneffectue}
   \end{travailnoneffectue}

   \begin{echange}
    \begin{itemize}
   	\item Visio-conférence à propos du projet
   	\end{itemize}
   \end{echange}

   \begin{planification}
      	\begin{itemize}
   	\item Estimer à nouveau le dimensionnement de la base de données de façon plus fine
   	\item Recherches sur le RSSI et début d'utilisation
   	\end{itemize}
   \end{planification}
\end{fichesuivi}

\begin{fichesuivi}{23 Décembre 2019}{29 Décembre 2019}
   \tempstravailA{0}{0}
   \tempstravailB{0}{0}

   Aucun travail effectué car vacances de Noël
\end{fichesuivi}

\begin{fichesuivi}{30 Décembre 2019}{5 Janvier 2020}
   \tempstravailA{0}{0}
   \tempstravailB{0}{0}

   Aucun travail effectué car vacances de Noël
\end{fichesuivi}

\begin{fichesuivi}{6 Janvier 2020}{12 Janvier 2020}
   \tempstravailA{10}{30}
   \tempstravailB{10}{0}

   \begin{travaileffectue}
      	\begin{itemize}
   	\item Recherches bibliographiques sur le lien entre RSSI / Présence humaine
   	\item Tests de captation des données RSSI sur les n\oe uds M3
   	\item Affinage de l'estimation de stockage des données dans une base InfluxDB
   	\item Captation du RSSI pendant la captation de données
   	\item Premiers tests d'affichage des données avec Grafana
   	\end{itemize}
   \end{travaileffectue}

   \begin{travailnoneffectue}
   \end{travailnoneffectue}

   \begin{echange}
   \end{echange}

   \begin{planification}
      	\begin{itemize}
   	\item Poursuivre les recherches bibliograpgiques
   	\item Amorcer la rédaction du rapport final
   	\item Finaliser le code de captation du RSSI
   	\item Design d'une expérience afin de répondre à notre problématique
   	\end{itemize}
   \end{planification}
\end{fichesuivi}

\begin{fichesuivi}{13 Janvier 2020}{19 Janvier 2020}
   \tempstravailA{11}{30}
   \tempstravailB{9}{0}

   \begin{travaileffectue}
      	\begin{itemize}
   	\item Lecture et recherche d'articles
   	\item Travail sur Grafana
   	\item Inclusion du RSSI dans les données capturées
   	\item Ajustement du schéma de la base de données
   	\end{itemize}
   \end{travaileffectue}

   \begin{travailnoneffectue}
   \end{travailnoneffectue}

   \begin{echange}
      	\begin{itemize}
   	\item Réunion visioconférence pour définir les objectifs finaux du projet
   	\item Echanges mail autour d'un souci sur CRON
   	\end{itemize}
   \end{echange}

   \begin{planification}
      	\begin{itemize}
   	\item Réunion visio-conférence
   	\item Finalisation du dimensionnement de la base de données
   	\item Développement des expériences de collecte de données
   	\item Début d'exploitation des données collectées
   	\item Finalisation de la rechefche bibliographiques
   	\item Début de rédaction du rapport final
   	\end{itemize}
   \end{planification}
\end{fichesuivi}

\begin{fichesuivi}{20 Janvier 2020}{26 Janvier 2020}
   \tempstravailA{25}{0}
   \tempstravailB{23}{0}

   \begin{travaileffectue}
      	\begin{itemize}
   	\item Déboggage de l'automatisation de la collecte de données
   	\item Recherches bibliographiques
   	\item Rédaction rapport
   	\end{itemize}
   \end{travaileffectue}

   \begin{travailnoneffectue}
   \end{travailnoneffectue}

   \begin{echange}
      	\begin{itemize}
   	\item Réunion visio-conférence
   	\end{itemize}
   \end{echange}

   \begin{planification}
      	\begin{itemize}
   	\item Collecte de données et exploitation
   	\item Rédaction du rapport
   	\item Réunion visio-conférence
   	\end{itemize}
   \end{planification}
\end{fichesuivi}

\begin{fichesuivi}{27 Janvier 2020}{2 Février 2020}
   \tempstravailA{0}{0}
   \tempstravailB{0}{0}

   \begin{travaileffectue}
   \end{travaileffectue}

   \begin{travailnoneffectue}
   \end{travailnoneffectue}

   \begin{echange}
   \end{echange}

   \begin{planification}
   \end{planification}
\end{fichesuivi}

\begin{fichesuivi}{3 Février 2020}{9 Février 2020}
   \tempstravailA{0}{0}
   \tempstravailB{0}{0}

   \begin{travaileffectue}
   \end{travaileffectue}

   \begin{travailnoneffectue}
   \end{travailnoneffectue}

   \begin{echange}
   \end{echange}

   \begin{planification}
   \end{planification}
\end{fichesuivi}

Le tableau récapitulatif du temps consacré au projet est \emph{obligatoire}.
Si vous n'utilisez pas strictement le modèle de fiche de suivi fourni, il vous faudra l'établir vous-même.
Dans le cas contraire, une commande permet de le générer automatiquement avec le texte qui le référence et des hyper-liens vers chacune des fiches (paragraphe ci-dessous).

\printweeksummary

\chapter{Auto-contrôle et auto-évaluation}

Cette annexe est \emph{obligatoire}.

La figure~\ref{fig:AutoEvaluationTravailIntermediaire} permet d'énumérer un certain nombre de points importants dans les trois composantes du travail~:
\begin{enumerate}
   \item rapport~;
   \item présentation orale~;
   \item travail de fond~;
\end{enumerate}
ainsi que d'évaluer notre niveau de satisfaction à l'issue de la phase~I, composée de trois étapes~:
\begin{enumerate}
   \item étude préalable~;
   \item étude bibliographique~;
   \item conception générale.
\end{enumerate}

Les points de satisfaction ou d'insatisfaction peuvent être approfondis.

\begin{figure*}
   \centering
      \ifscreen % macro TeX (issue de la classe report-rd-info.cls) permettant d'ajuster le contenu en fonction du l'orientation du document (<<~screen~>> ou pas)
         \rotatebox{90}{\includegraphics[width=0.9\textheight]{Images/Grille-Evaluation-PRD1}}
      \else
         \includegraphics[width=0.9\textwidth]{Images/Grille-Evaluation-PRD1}
      \fi
   \caption{Points à contrôler à l'issue de la phase I}
   \label{fig:AutoEvaluationTravailIntermediaire}
\end{figure*}

La figure~\ref{fig:AutoEvaluationTravailFinal} permet d'énumérer un certain nombre de points importants dans les trois composantes du travail ainsi que d'évaluer notre niveau de satisfaction à l'issue de la phase~II, constituée de~:
\begin{enumerate}
   \item la conception détaillée~;
   \item la réalisation~;
   \item la recette.
\end{enumerate}

\begin{figure*}
   \centering
      \ifscreen
         \rotatebox{90}{\includegraphics[width=0.9\textheight]{Images/Grille-Evaluation-PRD2}}
      \else
         \includegraphics[width=0.9\textwidth]{Images/Grille-Evaluation-PRD2}
      \fi
   \caption{Points à contrôler à l'issue de la phase II}
   \label{fig:AutoEvaluationTravailFinal}
\end{figure*}


\bibliography{biblio}
[1] Getting started with IoT-LAB : the tutorial for beginners -  https://www.iot-lab.info/tutorials/getting-started-tutorial/
\newline
\newline
[2] Configure your SSH access - https://www.iot-lab.info/tutorials/ssh-access/
\newline
\newline
[3] Experiment CLI client -  https://www.iot-lab.info/tutorials/iotlab-experimenttools-client/
\newline
\newline
[4] Nodes Serial Link Aggregation - \newline https://www.iot-lab.info/tutorials/serial-aggregator/
\newline
\newline
[5] - Compilation with RIOT, https://www.iot-lab.info/tutorials/riot-compilation/
\newline
\newline
[6] Survey and Comparison of Open Source Time Series Databases - Andreas Bader,Oliver Kopp,Michael Falkenthal - 2017
\newline
\newline
[7] Benchmarking Time Series Databases with IoTDB-Benchmark for IoT Scenarios - Rui Liu, Jun Yuan - 2019
\newline
\newline
[8] DB-Engines Ranking, \newline
https://db-engines.com/en/ranking/time+series+dbms
\newline
\newline
[9] Time Series Database (TSDB) Explained | InfluxDB - 
https://www.influxdata.com/time-series-database/
\newline
\newline
[10] Prometheus - Monitoring system and time series database - https://prometheus.io/
\newline
\newline
[11] RPL: IPv6 Routing Protocol for Low-Power and Lossy Networks
https://tools.ietf.org/html/rfc6550
\newline
\newline
[12] Sharing is caring: a cooperation scheme for RPL network resilience and efficiency - 2019 - Brandon Foubert, Julien Montavont - hal-02095410 
\newline
\newline
[13] IEEE Standard for Low-Rate Wireless Networks - IEEE 2015 - https://standards.ieee.org/content/ieee-standards/en/standard/802\_ 15\_ 4-2015.html
\newline
\newline
[14] IEEE Standard for Low-Rate Wireless Networks IEEE 2015 https://www.silabs.com/content/usergenerated/asi/cloud/attachments/siliconlabs/en/community/wireless/proprietary/forum/jcr:content/content/primary/qna/802\_ 15\_ 4\_ promiscuous-tbzR/hivukadin\_ vukadi-iTXQ/802.15.4-2015.pdf
\newline
\newline
[15 ] High-Throughput Routing forMulti-Hop Wireless Networks - Douglas S.J. De Couto - MIT 2004 - https://pdos.lcs.mit.edu/papers/grid:decouto-phd/thesis.pdf

\end{document}
